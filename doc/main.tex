\theoremstyle{remark}
\newtheorem{rem}{Remark}

\section{Game rules}

\begin{enumerate}
\item There are the following pieces:
  \begin{itemize}
  \item Pawn \pawn
  \item Knight \knight
  \item Bishop \bishop
  \item Rook \rook
  \item Queen \queen
  \item King \king
  \end{itemize}
\item The starting position is as in Figure~\ref{fig:reset}.
  \begin{figure}[!ht]
    \centering
    \newgame\showboard
    \caption{The starting position}
    \label{fig:reset}
  \end{figure}
\item Players move in turns, one move each, starting with the White,
  until the game ends.
\item The ending condition for a game is one of:
  \begin{enumerate}
  \item \emph{Draw by Stalemate}
  \item \emph{Draw by threefold repeat} 
  \item \emph{Checkmate}
  \item \emph{Resign}
  \end{enumerate}
\end{enumerate}

\clearpage \section{Implementation}

\begin{itemize}

\item Some enum types to begin with:
\begin{verbatim}
CREATE TYPE chesspiececlass AS ENUM (
  'Pawn' , 'Knight' , 'Bishop' , 'Rook' , 'Queen' , 'King' );

CREATE TYPE chess_square AS ENUM (
	'Black Pawn' , 'Black Knight' , 'Black Bishop' ,
	'Black Rook' , 'Black Queen' , 'Black King' ,
	'White Pawn' , 'White Knight' , 'White Bishop' , 
	'White Rook' , 'White Queen' , 'White King' ,
	'empty');
\end{verbatim}

\item the chessboard is an $8\times 8$ array of \verb+chess_square+

\item \emph{prevalid} move: move allowed by the movement rules of the
  piece

\item \emph{valid} move: prevalid move $M$\quad +\quad the moves
  immediately following $M$ cannot ``capture the King''

\item Custom type \verb+gamemove+, which represents a move. It
  includes:
  \begin{itemize}
  \item \verb+d_score :real+, as in ``difference in score''
  \item \verb+mine :d_chess_square+, specifying $(x_1,y_1)\mapsto(x_2,y_2)$.
  \item \verb+next :pregamemove[]+, a list of the next prevalid moves
  \end{itemize}
  \begin{rem}
    The different type is a workaround to emulate \emph{recursive
      types} which are not allowed.
  \end{rem}

\item Custom type \verb+gamestate+, to represent the state of a
  game. Includes:
  \begin{itemize}
  \item \verb+score :real+
  \item \verb+moves :gamemove[]+, previous moves
  \item \verb+next :pregamemove[]+, next possible moves
  \end{itemize}

  \begin{rem} The moves $M_1,\dots,M_n$ following a certain move $M$
    are usually needed twice:
    \begin{itemize}
    \item $M$ is allowed only if it doesn't leave its own King under
      attack, that is, if \emph{none of the $M_i$ can ``capture the
        King''}
    \item $M$ is more or less convenient according to
      \begin{itemize}
      \item the effects of $M_1,\dots,M_n$
      \item the effects of the moves following $M_1,\dots,M_n$
      \item the effects of the moves following the moves following
        $M_1,\dots,M_n$
      \item (etc.)
      \end{itemize}
    \end{itemize}
    Hence we store them.
  \end{rem}

\item Temporary table \verb+my_states+ represents a set of objects of
  type \verb+gamestate+. It has only one row, and encodes the current
  status of the match.

\item Temporary table \verb+my_moves+ represents a set of objects of
  type \verb+gamemove+.

\item The side of the player is represented by a \verb+boolean+ (Black
  and White respectively \verb+f+ and \verb+t+)

\item Function \verb+starting_gamestate() :gamestate+ creates a value
  of type \verb+gamestate+ corresponding to a chessboard which has
  been reset.

\item Function \verb+prevalid_moves(gamestate) :SETOF pregamemove+
  computes the set of prevalid moves which follow from a given state
  (function code is longer than average because it encodes all the
  Chess movement rules)

\item Function \verb+valid_moves(gamestate) :SETOF gamemove+ computes
  the set of valid moves which follow from a given state, filtering
  the output of \verb+prevalid_moves+ according to whether or not a
  given move leaves the own King under attack.

\item Function \verb+apply_move(gamestate,gamemove) :gamestate+
  applies the given move to the given state (including ``side
  effects'' such as promoting Pawns to Queens when they reach the
  other end).

\item Function \verb+ui_apply_best_move()+ selects the move with the
  highest total score from \verb+my_moves+ and applies it to
  \verb+my_states+.

\item Function \verb+ui_think_best_move()+ computes the total score
  for each move which follows \verb+my_states+, by considering all the
  sequences of allowed moves up to a certain ``level'', and summing
  the \verb+d_score+. It is implemented with a \emph{recursive query}.

\subsection{AI}

The score is quite simple:
\begin{itemize}
\item the usual score per piece captured
\item incentive to move Pawns: $k_1=0.1$ per step forward
\item incentive for check (including checkmate): $k_2/n$ where $n$ is
  the number of moves that the opponent can do to escape from
  check. Checkmate iff $n=0$, that is, \verb+d_score+ = $+\infty$.
\end{itemize}

\section{Optimisation}

\begin{verbatim}
             func              | calls  | total_ms |  avg_ms  
-------------------------------+--------+----------+----------
 chess.starting_gamestate      |      1 |        5 |    5.000
 chess.ui_reset                |      1 |       10 |   10.000
 chess.ui_display              |    154 |      150 |    0.974
 chess.display                 |    154 |      387 |    2.513
 chess.ui_apply_best_move      |    152 |     3454 |   22.724
 chess.pregamemove_as_gamemove |  60074 |     6322 |    0.105
 chess.valid_moves             |   4011 |    43902 |   10.945
 chess.apply_move              |  64083 |    99084 |    1.546
 chess.is_king_under_attack    |  60072 |   231384 |    3.852
 chess.prevalid_moves          |  64084 |   255449 |    3.986
 chess.ui_think_best_move      |    152 |   532134 | 3500.882
 chess.chesspiece_moves        | 435644 |   601432 |    1.381
\end{verbatim}


\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main-screen"
%%% End: 
